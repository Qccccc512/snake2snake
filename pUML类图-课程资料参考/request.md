类图
1. 舍弃无用的对象

通过属性判断：
是否通过属性记录了某些有用的信息？
通过服务判断：
是否通过服务提供了某些有用的功能？
二者都不是——无用
在应用中,一个对象应该为一些其他的对象提供服务。

2. 精简对象
只有一个属性的对象
只有一个服务的对象
总体上，对象必须具有多个属性和服务。也存在对象没有属性仅提供服务，或有属性无服务的情况。

3. 与实现条件有关的对象，推迟到OOD考虑
系统责任所要求的某些功能
例如系统安装、配置、信息备份、浏览——可能无法从问题域中找到相应的对象来提供这些功能，可在设计阶段考虑专门为它们增加一些对象，既把它们推迟到设计阶段考虑。
系统责任要求的某些功能可能与实现环境有关，也推迟到设计阶段考虑。
与图形用户界面（GUI）系统、数据管理系统、硬件和操作系统有关的对象。

4. 识别主动对象
考虑问题域和系统责任
哪些对象需呈现主动行为？--按定义
从需求考虑系统的执行情况
如果一切对象服务都是顺序执行的，那么首先执行的服务在哪个对象（唯一）？
如果需要并发执行，每条控制线程的起点在哪个对象？这样的对象都是主动对象。
考虑系统边界
哪些对象与参与者交互？
如果一个交互是由参与者发起的，
第一个处理该交互的对象是主动对象

5. 属性
特征0：属性必须捕获与其对象所在的语义域相一致的特征。
特征1：任何时间一个实例为其每一个属性都精确地给出一个值。
特征2：不能包含内部的结构。
人的姓+名
特征3：属性必须是整个实体的特征。
计算机的屏幕尺寸?显示器的屏幕尺寸
特征4：对象的属性必须与该对象相关。
油罐 倒 油瓶 的容器中的容积属性
特征5：对象的属性值不能是与其有关的对象的值以其关系的值。
人的薪水 结婚日期

按常识这个对象应该有哪些属性？􀂾
在当前的问题域中，对象应该有哪些属性？
根据系统责任，这个对象应具有哪些属性？
建立这个对象是为了保存和管理哪些信息？
对象为了完成其功能，需要增设哪些属性？
对象是否需要通过专设的属性区别其状态？
可利用需求文档中的形容词或所有格短语。

是否体现了以系统责任为目标的抽象；
是否描述对象本身的特征；
属性不能破坏对象特征的“原子性”；
属性必须是整个实体的特征，而不是其成分的特征；
若一个对象与另一个对象有关系，属性必须捕获该对象的性质，而不是关系或关系中的其他对象的性质；
是否可通过继承得到？
可以从其它属性直接导出的属性;
与实现有关的因素，推迟到OOD考虑（规范化、对象标识、性能问题）
若一个属性的结构较为复杂（即不仅仅是一些简单的数字或文本），可考虑把其作为对象。

命名：原则与类的命名相同
定位：针对所描述的对象，适合全部对象实例。

把每个属性都填写到相应的类符号中去，并在相应的类描述模板中进行详细说明。


6. 服务
概念与表示法
操作：是类的行为特征，用于描述为了引发相关行为的名称、类型、参数与约束。
有名字和参数表; 有可见性和返回类型。
可见性的取值为+(公有的)、#(受保护的)、-(私有的)或~(包内的)。
可见性、参数表和返回类型可在类描述模板中描述。
抽象操作:把在一个类中没有实现的操作（即没有提供方法）。
服务：一个类为其他类所做的工作。一个对象的服务是当其他对象借助消息传递机制请求它时，它愿意执行的所公布的或公开的工作。
方法：是操作的实现。当一个对象请求另一个对象的服务时对象完成的详细的动作集合（算法、过程）。
对象行为分类
系统行为
例：创建、删除、复制、转存等
对象自身的行为——算法简单的服务
例：读、写属性值等
对象自身的行为——算法复杂的服务
例：计算或监控等
类范围的操作用带下划线的名字和类型表达式串表示。实例范围的操作是默认的，对其不用标记。
抽象操作带有标记“{abstract}”，或者把操作的特征标记写成斜体来表示它是抽象的。
OOA不考虑算法简单服务
去创建、连接、访问、断开连接、删除等等。
考虑算法复杂的服务
由对象提供的、在算法上复杂的业务服务（如要进行某些计算或监控操作）。

定义服务的策略与启发
考虑系统责任
有哪些功能要求在本对象提供？
考虑问题域
对象在问题域对应的事物有哪些行为？
分析对象状态
在每种状态下对象可能发生什么行为？对象状态的转换，是由哪些服务引起的？
追踪服务的执行路线
模拟服务的执行，并在整个系统中跟踪。
用动词识别服务。
识别出计算、监视和查询类的服务。

审查与调整
审查对象的每个服务
是否真正有用
是否直接提供系统责任所要求的某项功能？
或者
响应其它服务的请求间接地完成这种功能的某些局部操作？
调整——取消无用的服务
是不是高内聚的
一个服务只完成一项单一的、完整的功能
调整——拆分或合并

认识对象的主动行为
考虑问题域对象行为是被引发的，还是主动呈现的？
与参与者交互的对象服务
完成最外层功能的对象服务外层与内层是请求与被请求的关系
服务执行路线逆向追踪找到了主动服务就等于找到了主动对象。

描述服务：
把每个对象的服务都填写到相应的类符号中。
在类描述模板中，写出：
说明服务的职责
服务原型（消息的格式）
消息发送（指出在这个服务执行时，需要请求哪些别的对象服务，即接收消息的对象类名以及执行这个消息的服务名）
约束条件：如果该服务的执行有前置条件、后置条件，以及执行时间的要求等其它需要说明的事项，则在这里加以说明。
实现服务的方法（文字、活动图或流程图）。


7. 定义关系
泛化关系
关联关系
聚合关系
依赖关系
接口与实现

泛化集的约束
{complete, disjoint}  
表明泛化集是覆盖的,并且某些特殊类没有共同的实例.
{incomplete, disjoint} 
表明泛化集不是覆盖的,并且某些特殊类没有共同的实例.
{complete, overlapping} 
表明泛化集是覆盖的,并且某些特殊类具有共同的实例.
{incomplete, overlapping} 
表明泛化集不是覆盖的,并且某些特殊类具有共同的实例.
 默认 {incomplete, disjoint}

审查与调整：
考虑问题域与系统责任，分类是否合理、必要？
是否符合分类学的常识？
是否构成了继承关系？（确实继承了一些属性或服务）

可以取消没有特殊性的特殊类：
从一般类划分出太多的特殊类，使系统中类的设置太多，增加了系统的复杂性；
建立过深的继承层次，增加了系统的理解难度和处理开销。

可以增设属性，以简化一般－特殊结构

取消用途单一的一般类，减少继承层次
一般类存在的理由
有两个或两个上以上的特殊类
需要用它创建对象实例
有助于软件复用